<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Methods â€¢ SCoRES Package</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Methods">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">SCoRES Package</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.1.0</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../articles/SCoRES.html">Get started</a></li>
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-vignettes" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Vignettes</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-vignettes">
<li><a class="dropdown-item" href="../articles/Functional_Data_Example.html">Functional Data Example</a></li>
    <li><a class="dropdown-item" href="../articles/Geographic_Data_Example.html">Geographic Data Example</a></li>
    <li><a class="dropdown-item" href="../articles/Linear_Model_Example.html">Linear Model Example</a></li>
    <li><a class="dropdown-item" href="../articles/Methods.html">Methods</a></li>
  </ul>
</li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/AngelaYuStat/SCoRES/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Methods</h1>
                        <h4 data-toc-skip class="author">Zhuoran
(Angela) Yu</h4>
            
            <h4 data-toc-skip class="date">2025-10-24</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/AngelaYuStat/SCoRES/blob/HEAD/vignettes/Methods.Rmd" class="external-link"><code>vignettes/Methods.Rmd</code></a></small>
      <div class="d-none name"><code>Methods.Rmd</code></div>
    </div>

    
    
<div class="section level2">
<h2 id="definition-of-inverse-set-and-introduction-of-the-estimation-method">Definition of Inverse Set and Introduction of the Estimation
Method<a class="anchor" aria-label="anchor" href="#definition-of-inverse-set-and-introduction-of-the-estimation-method"></a>
</h2>
<p>The identification of domain sets whose outcomes belong to predefined
subsets can address fundamental risk assessment challenges in
climatology and medicine. A motivating example involves estimating
geographical regions where average difference between summer and winter
temperatures exceeds a certain benchmark, which helps policymakers focus
on specific areas that are at higher risk for effects of climate
change.</p>
<p>Mathematically, the target region corresponding to the inverse image
of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo>âŠ‚</mo><mi>â„</mi></mrow><annotation encoding="application/x-tex">U \subset  \mathbb{R}</annotation></semantics></math>
under an unknown function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Î¼</mi><mo>:</mo><mi>ğ’®</mi><mo>â†’</mo><mi>â„</mi></mrow><annotation encoding="application/x-tex">\mu: \mathcal{S} \to \mathbb{R}</annotation></semantics></math>,
can be defined as
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>Î¼</mi><mrow><mi>âˆ’</mi><mn>1</mn></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>U</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>s</mi><mo>âˆˆ</mo><mi>S</mi><mo>:</mo><mi>Î¼</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>âˆˆ</mo><mi>U</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">
\mu^{-1}(U) = \{s \in S: \mu(s) \in U\}
</annotation></semantics></math> , with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>U</mi><annotation encoding="application/x-tex">U</annotation></semantics></math>
a pre-specified subset of a real line
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>â„</mi><annotation encoding="application/x-tex">\mathbb{R}</annotation></semantics></math>
(e.g.,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mi>c</mi><mo>,</mo><mi>âˆ</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">[c, \infty)</annotation></semantics></math>).</p>
<p>A point estimator for the inverse set can be constructed as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mover><mi>Î¼</mi><mo accent="true">Ì‚</mo></mover><mi>n</mi><mrow><mi>âˆ’</mi><mn>1</mn></mrow></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>U</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat{\mu}_n^{-1}(U)</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>Î¼</mi><mo accent="true">Ì‚</mo></mover><mi>n</mi></msub><annotation encoding="application/x-tex">\hat{\mu}_n</annotation></semantics></math>
is an empirical estimator of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Î¼</mi><annotation encoding="application/x-tex">\mu</annotation></semantics></math>
based on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
observations. To quantify the spatial uncertainty of this estimate,
<span class="citation">Sommerfeld et al. (2018)</span> introduced the
Coverage Probability Excursion (CoPE) sets, defined as:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext mathvariant="normal">CR</mtext><mtext mathvariant="normal">in</mtext></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>U</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>âŠ†</mo><msup><mi>Î¼</mi><mrow><mi>âˆ’</mi><mn>1</mn></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>U</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>âŠ†</mo><msub><mtext mathvariant="normal">CR</mtext><mtext mathvariant="normal">out</mtext></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>U</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
\text{CR}_{\text{in}}(U) \subseteq \mu^{-1}(U) \subseteq \text{CR}_{\text{out}}(U)
</annotation></semantics></math> which satisfy:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>â„™</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mtext mathvariant="normal">CR</mtext><mtext mathvariant="normal">in</mtext></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>U</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>âŠ†</mo><msup><mi>Î¼</mi><mrow><mi>âˆ’</mi><mn>1</mn></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>U</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>âŠ†</mo><msub><mtext mathvariant="normal">CR</mtext><mtext mathvariant="normal">out</mtext></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>U</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>â‰¥</mo><mn>1</mn><mo>âˆ’</mo><mi>Î±</mi></mrow><annotation encoding="application/x-tex">
\mathbb{P}\left(\text{CR}_{\text{in}}(U) \subseteq \mu^{-1}(U) \subseteq \text{CR}_{\text{out}}(U)\right) \geq 1 - \alpha
</annotation></semantics></math> for a pre-specified confidence level
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>âˆ’</mo><mi>Î±</mi></mrow><annotation encoding="application/x-tex">1-\alpha</annotation></semantics></math>
(e.g.,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Î±</mi><mo>=</mo><mn>0.05</mn></mrow><annotation encoding="application/x-tex">\alpha = 0.05</annotation></semantics></math>).</p>
<p>Existing approaches require restrictive assumptions, including domain
density of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math>
in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>,
continuity of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>Î¼</mi><mo accent="true">Ì‚</mo></mover><mi>n</mi></msub><annotation encoding="application/x-tex">\hat{\mu}_n</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Î¼</mi><annotation encoding="application/x-tex">\mu</annotation></semantics></math>
near thresholds, and large-sample guarantees, which limit the
applicability. Besides, the estimation and coverage depend on setting a
fixed threshold level, which is difficult to determine.</p>
<p><span class="citation">Ren et al. (2024)</span> proposed a framework
that generalizes the estimation of such inverse sets to dense and
non-dense domains with protection against inflated Type I error, and
constructs multiple upper, lower or interval confidence regions of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>Î¼</mi><mrow><mi>âˆ’</mi><mn>1</mn></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>U</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mu^{-1}(U)</annotation></semantics></math>
over arbitrary chosen thresholds. The coverage probability is achieved
non-asymptotically and simultaneously through inverting simultaneous
confidence intervals. For instance, suppose we are interested in inverse
regions
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>Î¼</mi><mrow><mi>âˆ’</mi><mn>1</mn></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mo stretchy="false" form="prefix">[</mo><mi>c</mi><mo>,</mo><mi>âˆ</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mu^{-1}([c,\infty))</annotation></semantics></math>
for a single value
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>,
the inverse confidence regions are constructed by inverting simultaneous
confidence intervals (SCIs). Given SCI bounds
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>B</mi><mo accent="true">Ì‚</mo></mover><mi>l</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>ğ¬</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat{B}_{l}(\boldsymbol{s})</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>B</mi><mo accent="true">Ì‚</mo></mover><mi>u</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>ğ¬</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat{B}_{u}(\boldsymbol{s})</annotation></semantics></math>
satisfying:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>â„™</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo>âˆ€</mo><mi>ğ¬</mi><mo>âˆˆ</mo><mi>ğ’®</mi><mo>:</mo><msub><mover><mi>B</mi><mo accent="true">Ì‚</mo></mover><mi>l</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>ğ¬</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>â‰¤</mo><mi>Î¼</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>ğ¬</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>â‰¤</mo><msub><mover><mi>B</mi><mo accent="true">Ì‚</mo></mover><mi>u</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>ğ¬</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>1</mn><mo>âˆ’</mo><mi>Î±</mi></mrow><annotation encoding="application/x-tex">
\mathbb{P}\left(\forall\boldsymbol{s}\in\mathcal{S}: \hat{B}_{l}(\boldsymbol{s}) \leq \mu(\boldsymbol{s}) \leq \hat{B}_{u}(\boldsymbol{s})\right) = 1-\alpha
</annotation></semantics></math></p>
<p>The inner and outer confidence regions (CRs) for the inverse upper
excursion set
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>Î¼</mi><mrow><mi>âˆ’</mi><mn>1</mn></mrow></msup><mo stretchy="false" form="prefix">[</mo><mi>c</mi><mo>,</mo><mi>âˆ</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mu^{-1}[c, \infty)</annotation></semantics></math>
are defined as:<br><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext mathvariant="normal">CR</mtext><mtext mathvariant="normal">in</mtext></msub><mo stretchy="false" form="prefix">[</mo><mi>c</mi><mo>,</mo><mi>âˆ</mi><mo stretchy="false" form="postfix">)</mo><mo>:=</mo><msubsup><mover><mi>B</mi><mo accent="true">Ì‚</mo></mover><mo>â„“</mo><mrow><mi>âˆ’</mi><mn>1</mn></mrow></msubsup><mo stretchy="false" form="prefix">[</mo><mi>c</mi><mo>,</mo><mi>âˆ</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">
\text{CR}_{\text{in}}[c, \infty) := \hat{B}_\ell^{-1}[c, \infty)
</annotation></semantics></math></p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext mathvariant="normal">CR</mtext><mtext mathvariant="normal">out</mtext></msub><mo stretchy="false" form="prefix">[</mo><mi>c</mi><mo>,</mo><mi>âˆ</mi><mo stretchy="false" form="postfix">)</mo><mo>:=</mo><msubsup><mover><mi>B</mi><mo accent="true">Ì‚</mo></mover><mi>u</mi><mrow><mi>âˆ’</mi><mn>1</mn></mrow></msubsup><mo stretchy="false" form="prefix">[</mo><mi>c</mi><mo>,</mo><mi>âˆ</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">
\text{CR}_{\text{out}}[c,\infty) := \hat{B}_u^{-1}[c, \infty)
</annotation></semantics></math></p>
<p>The outer and inner confidence regions for the inverse lower
excursion set
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>Î¼</mi><mrow><mi>âˆ’</mi><mn>1</mn></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>âˆ’</mi><mi>âˆ</mi><mo>,</mo><mi>c</mi><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">\mu^{-1}\left(-\infty, c\right]</annotation></semantics></math>
are defined as:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext mathvariant="normal">CR</mtext><mtext mathvariant="normal">in</mtext></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>âˆ’</mi><mi>âˆ</mi><mo>,</mo><mi>c</mi><mo stretchy="true" form="postfix">]</mo></mrow><mo>:=</mo><msubsup><mover><mi>B</mi><mo accent="true">Ì‚</mo></mover><mi>u</mi><mrow><mi>âˆ’</mi><mn>1</mn></mrow></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>âˆ’</mi><mi>âˆ</mi><mo>,</mo><mi>c</mi><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mover><mi>B</mi><mo accent="true">Ì‚</mo></mover><mi>u</mi><mrow><mi>âˆ’</mi><mn>1</mn></mrow></msubsup><mrow><mo stretchy="true" form="prefix">[</mo><mi>c</mi><mo>,</mo><mi>+</mi><mi>âˆ</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mi>âˆ</mi></msup></mrow><annotation encoding="application/x-tex">
\text{CR}_{\text{in}}\left(-\infty, c\right] := \hat{B}_u^{-1}\left(-\infty, c\right]
= \left( \hat{B}_u^{-1}\left[c, +\infty\right) \right)^{\complement}
</annotation></semantics></math><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext mathvariant="normal">CR</mtext><mtext mathvariant="normal">out</mtext></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>âˆ’</mi><mi>âˆ</mi><mo>,</mo><mi>c</mi><mo stretchy="true" form="postfix">]</mo></mrow><mo>:=</mo><msubsup><mover><mi>B</mi><mo accent="true">Ì‚</mo></mover><mo>â„“</mo><mrow><mi>âˆ’</mi><mn>1</mn></mrow></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>âˆ’</mi><mi>âˆ</mi><mo>,</mo><mi>c</mi><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mover><mi>B</mi><mo accent="true">Ì‚</mo></mover><mo>â„“</mo><mrow><mi>âˆ’</mi><mn>1</mn></mrow></msubsup><mrow><mo stretchy="true" form="prefix">[</mo><mi>c</mi><mo>,</mo><mi>+</mi><mi>âˆ</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mi>âˆ</mi></msup></mrow><annotation encoding="application/x-tex">
\text{CR}_{\text{out}}\left(-\infty, c\right] := \hat{B}_\ell^{-1}\left(-\infty, c\right]
= \left( \hat{B}_\ell^{-1}\left[c, +\infty\right) \right)^{\complement}
</annotation></semantics></math></p>
<p>The inner and outer CRs for the inverse interval set
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>Î¼</mi><mrow><mi>âˆ’</mi><mn>1</mn></mrow></msup><mrow><mo stretchy="true" form="prefix">[</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">\mu^{-1}[a, b]</annotation></semantics></math>
are defined as:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext mathvariant="normal">CR</mtext><mtext mathvariant="normal">in</mtext></msub><mrow><mo stretchy="true" form="prefix">[</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="true" form="postfix">]</mo></mrow><mo>:=</mo><msubsup><mover><mi>B</mi><mo accent="true">Ì‚</mo></mover><mo>â„“</mo><mrow><mi>âˆ’</mi><mn>1</mn></mrow></msubsup><mrow><mo stretchy="true" form="prefix">[</mo><mi>a</mi><mo>,</mo><mi>âˆ</mi><mo stretchy="false" form="postfix">)</mo><mo>âˆ©</mo><msubsup><mover><mi>B</mi><mo accent="true">Ì‚</mo></mover><mi>u</mi><mrow><mi>âˆ’</mi><mn>1</mn></mrow></msubsup><mo stretchy="false" form="prefix">(</mo><mi>âˆ’</mi><mi>âˆ</mi><mo>,</mo><mi>b</mi><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">
\text{CR}_{\text{in}}[a, b] := \hat{B}_\ell^{-1}[a, \infty) \cap \hat{B}_u^{-1}(-\infty, b]
</annotation></semantics></math></p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext mathvariant="normal">CR</mtext><mtext mathvariant="normal">out</mtext></msub><mrow><mo stretchy="true" form="prefix">[</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="true" form="postfix">]</mo></mrow><mo>:=</mo><msubsup><mover><mi>B</mi><mo accent="true">Ì‚</mo></mover><mi>u</mi><mrow><mi>âˆ’</mi><mn>1</mn></mrow></msubsup><mrow><mo stretchy="true" form="prefix">[</mo><mi>a</mi><mo>,</mo><mi>âˆ</mi><mo stretchy="false" form="postfix">)</mo><mo>âˆ©</mo><msubsup><mover><mi>B</mi><mo accent="true">Ì‚</mo></mover><mo>â„“</mo><mrow><mi>âˆ’</mi><mn>1</mn></mrow></msubsup><mo stretchy="false" form="prefix">(</mo><mi>âˆ’</mi><mi>âˆ</mi><mo>,</mo><mi>b</mi><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">
\text{CR}_{\text{out}}[a, b] := \hat{B}_u^{-1}[a, \infty) \cap \hat{B}_\ell^{-1}(-\infty, b]
</annotation></semantics></math></p>
</div>
<div class="section level2">
<h2 id="linear-function-on-scalar-regression-fosr">Linear Function-on-Scalar Regression (FoSR)<a class="anchor" aria-label="anchor" href="#linear-function-on-scalar-regression-fosr"></a>
</h2>
<p>A simple example for function-on-scalar regression model is</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Y</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>Î²</mi><mn>0</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msub><mi>Î²</mi><mn>1</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>X</mi><mrow><mi>i</mi><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>b</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msub><mi>Ïµ</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mrow><annotation encoding="application/x-tex">
Y_i(t) = \beta_0(t) + \beta_1(t) X_{i1} + b_i(t) + \epsilon_i(t),
</annotation></semantics></math></p>
<p>where:</p>
<ul>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Y</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">Y_i(t)</annotation></semantics></math>
is a functional outcome</li>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mrow><mi>i</mi><mn>1</mn></mrow></msub><annotation encoding="application/x-tex">X_{i1}</annotation></semantics></math>
is a scalar covariate</li>
<li>Each
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Î²</mi><mi>j</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\beta_j(t)</annotation></semantics></math>
is a coefficient function<br>
</li>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">b_i(t)</annotation></semantics></math>
is a subject-specific functional random effect. This captures
correlation within subjects over time that is not captured by the mean.
This term is not always included in FoSR models, but itâ€™s generally a
good idea because it gives better inference<br>
</li>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Ïµ</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\epsilon_i(t)</annotation></semantics></math>
are normally distributed iid errors</li>
</ul>
<p>Here, the same bases are used for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Î²</mi><mn>1</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\beta_1(t)</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Î²</mi><mn>2</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\beta_2(t)</annotation></semantics></math>.</p>
<div class="section level3">
<h3 id="accounting-for-error-correlation">Accounting for Error Correlation<a class="anchor" aria-label="anchor" href="#accounting-for-error-correlation"></a>
</h3>
<p>The fitted GAM model above didnâ€™t take the correlation of residuals
into account. Here, we combined random effects and FPCA into the GAM
model to resolve this.</p>
<div class="section level4">
<h4 id="modeling-residuals-with-fpca-and-gam">Modeling residuals with FPCA and gam<a class="anchor" aria-label="anchor" href="#modeling-residuals-with-fpca-and-gam"></a>
</h4>
<p>First, fit the mean model:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Y</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>Î²</mi><mn>0</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msub><mi>Î²</mi><mn>1</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>X</mi><mrow><mi>i</mi><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>e</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mrow><annotation encoding="application/x-tex">
Y_i(t) = \beta_0(t) + \beta_1(t) X_{i1} + e_i(t),
</annotation></semantics></math></p>
</div>
<div class="section level4">
<h4 id="estimate-the-fpca-for-gamm-fpca-model">Estimate the FPCA for GAMM FPCA model<a class="anchor" aria-label="anchor" href="#estimate-the-fpca-for-gamm-fpca-model"></a>
</h4>
<p>After obtaining residuals from the mean model, FPCA models the
residuals using equation
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>b</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msub><mi>Ïµ</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">e_i(s) = b_i(s) + \epsilon_i(s)</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">b_i(s)</annotation></semantics></math>
follows a mean zero Gaussian Process (GP) with covariance function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Î£</mi><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math>,
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Ïµ</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\epsilon_i(s)</annotation></semantics></math>
are independent
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><msubsup><mi>Ïƒ</mi><mi>e</mi><mn>2</mn></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">N(0, \sigma_e^2)</annotation></semantics></math>
random errors.</p>
<p>Assuming that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Ï•</mi><mi>k</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>â‹…</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\phi_k(\cdot)</annotation></semantics></math>
are the eigenfunctions of the covariance operator
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>K</mi><mi>X</mi></msub><annotation encoding="application/x-tex">K_X</annotation></semantics></math>
of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>â‹…</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">b_i(\cdot)</annotation></semantics></math>,
one can express:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><munderover><mo>âˆ‘</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mo accent="false">âˆ</mo></munderover><msub><mi>Î¾</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub><msub><mi>Ï•</mi><mi>k</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
b_i(t) = \sum_{k=1}^{\infty} \xi_{ik} \phi_k(t)
</annotation></semantics></math></p>
<p>The GAMM-FPCA model will be :</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Y</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>Î²</mi><mn>0</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msub><mi>Î²</mi><mn>1</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>X</mi><mrow><mi>i</mi><mn>1</mn></mrow></msub><mo>+</mo><munderover><mo>âˆ‘</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>K</mi></munderover><msub><mi>Î¾</mi><mrow><mi>i</mi><mi>k</mi></mrow></msub><msub><mi>Ï•</mi><mi>k</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msub><mi>Ïµ</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mrow><annotation encoding="application/x-tex">
Y_i(t) = \beta_0(t) + \beta_1(t) X_{i1} + \sum_{k=1}^{K} \xi_{ik} \phi_k(t) + \epsilon_i(t),
</annotation></semantics></math></p>
</div>
</div>
</div>
<div class="section level2">
<h2 id="construction-of-simultaneous-confidence-bands-for-functional-regression-model">Construction of Simultaneous Confidence Bands for Functional
Regression Model<a class="anchor" aria-label="anchor" href="#construction-of-simultaneous-confidence-bands-for-functional-regression-model"></a>
</h2>
<p>We consider simultaneous confidence bands (SCBs) for a target
function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Î·</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>â‹…</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\eta(\cdot)</annotation></semantics></math>
on a grid
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ’®</mi><annotation encoding="application/x-tex">\mathcal{S}</annotation></semantics></math>.
For example,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Î·</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>â‹…</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\eta(\cdot)</annotation></semantics></math>
could be
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Y</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">Y_i(t)</annotation></semantics></math>
or
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Î²</mi><mn>1</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\beta_1(t)</annotation></semantics></math>.
Given an estimator
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>Î·</mi><mo accent="true">Ì‚</mo></mover><mi>N</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat{\eta}_N(s)</annotation></semantics></math>
with pointwise standard error
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>Î¶</mi><mo accent="true">Ì‚</mo></mover><mi>N</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat{\zeta}_N(s)</annotation></semantics></math>
and a normalizing factor
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Ï„</mi><mi>N</mi></msub><annotation encoding="application/x-tex">\tau_N</annotation></semantics></math>,
we can define the simultaneous confidence band for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Î·</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>â‹…</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\eta(\cdot)</annotation></semantics></math>
as:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">S</mi><mi mathvariant="normal">C</mi><mi mathvariant="normal">B</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo>;</mo><msub><mi>q</mi><mrow><mi>Î±</mi><mo>,</mo><mi>N</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mo minsize="1.8" maxsize="1.8" stretchy="false" form="prefix">[</mo><mspace width="0.167em"></mspace><msub><mover><mi>Î·</mi><mo accent="true">Ì‚</mo></mover><mi>N</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>âˆ’</mo><msub><mi>q</mi><mrow><mi>Î±</mi><mo>,</mo><mi>N</mi></mrow></msub><mfrac displaystyle="false"><mrow><msub><mover><mi>Î¶</mi><mo accent="true">Ì‚</mo></mover><mi>N</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><msub><mi>Ï„</mi><mi>N</mi></msub></mfrac><mo>,</mo><mspace width="0.278em"></mspace><msub><mover><mi>Î·</mi><mo accent="true">Ì‚</mo></mover><mi>N</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msub><mi>q</mi><mrow><mi>Î±</mi><mo>,</mo><mi>N</mi></mrow></msub><mfrac displaystyle="false"><mrow><msub><mover><mi>Î¶</mi><mo accent="true">Ì‚</mo></mover><mi>N</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><msub><mi>Ï„</mi><mi>N</mi></msub></mfrac><mo minsize="1.8" maxsize="1.8" stretchy="false" form="postfix">]</mo><mi>.</mi></mrow><annotation encoding="application/x-tex">
\mathrm{SCB}(s;q_{\alpha,N})
= \Big[\, \hat{\eta}_N(s) - q_{\alpha,N}\tfrac{\hat{\zeta}_N(s)}{\tau_N},\;
              \hat{\eta}_N(s) + q_{\alpha,N}\tfrac{\hat{\zeta}_N(s)}{\tau_N} \Big].
</annotation></semantics></math> And we can verify that these bands
achieve
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>âˆ’</mo><mi>Î±</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(1-\alpha)</annotation></semantics></math>
simultaneous coverage by
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>â„™</mi><mspace width="-0.167em"></mspace><mrow><mo stretchy="true" form="prefix">(</mo><mo>âˆ€</mo><mi>s</mi><mo>âˆˆ</mo><mi>ğ’®</mi><mo>:</mo><mspace width="0.278em"></mspace><mi>Î·</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>âˆˆ</mo><mrow><mi mathvariant="normal">S</mi><mi mathvariant="normal">C</mi><mi mathvariant="normal">B</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo>;</mo><msub><mi>q</mi><mrow><mi>Î±</mi><mo>,</mo><mi>N</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>1</mn><mo>âˆ’</mo><mi>Î±</mi><mo>,</mo></mrow><annotation encoding="application/x-tex">
\mathbb{P}\!\left(\forall s\in\mathcal{S}:\; \eta(s)\in \mathrm{SCB}(s;q_{\alpha,N})\right)=1-\alpha,
</annotation></semantics></math> whenever the critical value
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>q</mi><mrow><mi>Î±</mi><mo>,</mo><mi>N</mi></mrow></msub><annotation encoding="application/x-tex">q_{\alpha,N}</annotation></semantics></math>
satisfies
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>â„™</mi><mspace width="-0.167em"></mspace><mrow><mo stretchy="true" form="prefix">(</mo><munder><mo>max</mo><mrow><mi>s</mi><mo>âˆˆ</mo><mi>ğ’®</mi></mrow></munder><mspace width="0.167em"></mspace><msub><mi>Ï„</mi><mi>N</mi></msub><mspace width="0.167em"></mspace><mfrac><mrow><msub><mover><mi>Î·</mi><mo accent="true">Ì‚</mo></mover><mi>N</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>âˆ’</mo><mi>Î·</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><msub><mover><mi>Î¶</mi><mo accent="true">Ì‚</mo></mover><mi>N</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac><mspace width="0.278em"></mspace><mo>&gt;</mo><mspace width="0.278em"></mspace><msub><mi>q</mi><mrow><mi>Î±</mi><mo>,</mo><mi>N</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>Î±</mi><mi>.</mi></mrow><annotation encoding="application/x-tex">
\mathbb{P}\!\left(\max_{s\in\mathcal{S}}\, \tau_N\,
\frac{\hat{\eta}_N(s)-\eta(s)}{\hat{\zeta}_N(s)} \;&gt;\; q_{\alpha,N}\right)=\alpha. 
</annotation></semantics></math></p>
<p>The
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>q</mi><mrow><mi>Î±</mi><mo>,</mo><mi>N</mi></mrow></msub><annotation encoding="application/x-tex">q_{\alpha,N}</annotation></semantics></math>
is unknown in practice. In SCoRES, we implement two approaches for
estimating the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>q</mi><mrow><mi>Î±</mi><mo>,</mo><mi>N</mi></mrow></msub><annotation encoding="application/x-tex">q_{\alpha,N}</annotation></semantics></math>
for functional parameter functions in FoSR model: the Correlation and
Multiplicity-Adjusted (CMA) bands (<span class="citation">Crainiceanu et
al. (2024)</span>) based on parameter simulations, and a multiplier
bootstrap procedure (<span class="citation">Telschow &amp; Schwartzman
(2022)</span>). We detail the CMA procedure below:</p>
<div class="section level3">
<h3 id="correlation-and-multiplicity-adjusted-cma-confidence-bands-based-on-parameter-simulations">Correlation and Multiplicity Adjusted (CMA) Confidence Bands Based
on Parameter Simulations<a class="anchor" aria-label="anchor" href="#correlation-and-multiplicity-adjusted-cma-confidence-bands-based-on-parameter-simulations"></a>
</h3>
<ol style="list-style-type: decimal">
<li><p>Simulate model parameters
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ğ›ƒ</mi><mn>1</mn></msub><mo>,</mo><mi>â€¦</mi><mo>,</mo><msub><mi>ğ›ƒ</mi><mi>B</mi></msub><mover><mo>âˆ¼</mo><mtext mathvariant="normal">i.i.d.</mtext></mover><mi>ğ’©</mi><mrow><mo stretchy="true" form="prefix">(</mo><mover><mi>ğ›ƒ</mi><mo accent="true">Ì‚</mo></mover><mo>,</mo><msub><mover><mi>V</mi><mo accent="true">Ì‚</mo></mover><mi>ğ›ƒ</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\boldsymbol{\beta}_1, \ldots, \boldsymbol{\beta}_B \overset{\text{i.i.d.}}{\sim} \mathcal{N}(\hat{\boldsymbol{\beta}}, \hat{V}_{\boldsymbol{\beta}})</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mover><mi>ğ›ƒ</mi><mo accent="true">Ì‚</mo></mover><mo>,</mo><msub><mover><mi>V</mi><mo accent="true">Ì‚</mo></mover><mi>ğ›ƒ</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(\hat{\boldsymbol{\beta}}, \hat{V}_{\boldsymbol{\beta}})</annotation></semantics></math>
are estimated from a fitted FoSR model.</p></li>
<li><p>For each
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>â€¦</mi><mo>,</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">b=1,\ldots,B</annotation></semantics></math>,
compute
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ğ—</mi><mi>b</mi></msub><mspace width="0.278em"></mspace><mo>=</mo><mspace width="0.278em"></mspace><mfrac><mrow><mi>ğ</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Î²</mi><mi>b</mi></msub><mo>âˆ’</mo><mover><mi>Î²</mi><mo accent="true">Ì‚</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow></mrow><msub><mi>ğƒ</mi><mi>f</mi></msub></mfrac><mo>,</mo></mrow><annotation encoding="application/x-tex">
\mathbf{X}_b \;=\; \frac{\mathbf{B}(\beta_b - \hat{\beta})}{\mathbf{D}_f},
</annotation></semantics></math> where the division is element-wise and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ</mi><annotation encoding="application/x-tex">\mathbf{B}</annotation></semantics></math>
maps parameters to functional effects.</p></li>
<li><p>Define
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>b</mi></msub><mspace width="0.278em"></mspace><mo>=</mo><mspace width="0.278em"></mspace><mo>max</mo><mspace width="-0.167em"></mspace><mo minsize="1.2" maxsize="1.2" stretchy="false" form="prefix">(</mo><mrow><mo stretchy="true" form="prefix">|</mo><msub><mi>ğ—</mi><mi>b</mi></msub><mo stretchy="true" form="postfix">|</mo></mrow><mo minsize="1.2" maxsize="1.2" stretchy="false" form="postfix">)</mo><mo>,</mo><mspace width="1.0em"></mspace><mi>b</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>â€¦</mi><mo>,</mo><mi>B</mi><mo>,</mo></mrow><annotation encoding="application/x-tex">
d_b \;=\; \max\!\big(|\mathbf{X}_b|\big), \quad b=1,\ldots,B,
</annotation></semantics></math> where the absolute value is taken
element-wise.</p></li>
<li><p>Estimate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>q</mi><mrow><mi>Î±</mi><mo>,</mo><mi>N</mi></mrow></msub><annotation encoding="application/x-tex">q_{\alpha,N}</annotation></semantics></math>
as the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>âˆ’</mo><mi>Î±</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>â‹…</mo><mn>100</mn><mi>%</mi></mrow><annotation encoding="application/x-tex">(1 - \alpha) \cdot 100\%</annotation></semantics></math>
quantile of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><msub><mi>d</mi><mn>1</mn></msub><mo>,</mo><mi>â€¦</mi><mo>,</mo><msub><mi>d</mi><mi>B</mi></msub><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{d_1,\ldots,d_B\}</annotation></semantics></math>.</p></li>
</ol>
</div>
<div class="section level3">
<h3 id="multiplier-t-bootstrap-procedure-for-constructing-confidence-bands">Multiplier-t Bootstrap Procedure for Constructing Confidence
Bands<a class="anchor" aria-label="anchor" href="#multiplier-t-bootstrap-procedure-for-constructing-confidence-bands"></a>
</h3>
<p>The second is the multiplier-t bootstrap procedure for constructing
confidence bands. A full introduction to the method can be found in
previous work from .</p>
<ol style="list-style-type: decimal">
<li><p>Compute residuals
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>R</mi><mn>1</mn><mi>N</mi></msubsup><mo>,</mo><mi>â€¦</mi><mo>,</mo><msubsup><mi>R</mi><mi>N</mi><mi>N</mi></msubsup></mrow><annotation encoding="application/x-tex">R_1^N, \ldots, R_N^N</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>R</mi><mi>n</mi><mi>N</mi></msubsup><mo>=</mo><msqrt><mfrac><mi>N</mi><mrow><mi>N</mi><mo>âˆ’</mo><mn>1</mn></mrow></mfrac></msqrt><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>Y</mi><mi>n</mi></msub><mo>âˆ’</mo><msub><mover><mi>Î¼</mi><mo accent="true">Ì‚</mo></mover><mi>N</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">R_n^N = \sqrt{\frac{N}{N - 1}} \left( Y_n - \hat{\mu}_N \right)</annotation></semantics></math>,
and multipliers
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>g</mi><mn>1</mn></msub><mo>,</mo><mi>â€¦</mi><mo>,</mo><msub><mi>g</mi><mi>N</mi></msub><mover><mo>âˆ¼</mo><mtext mathvariant="normal">i.i.d.</mtext></mover><mi>g</mi></mrow><annotation encoding="application/x-tex">g_1, \ldots, g_N \overset{\text{i.i.d.}}{\sim} g</annotation></semantics></math>
with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ”¼</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>g</mi><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\mathbb{E}[g] = 0</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">v</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi></mrow><mrow><mo stretchy="true" form="prefix">[</mo><mi>g</mi><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\mathrm{var}[g] = 1</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>Î¼</mi><mo accent="true">Ì‚</mo></mover><mi>N</mi></msub><annotation encoding="application/x-tex">\hat{\mu}_N</annotation></semantics></math>
is the fitted mean value from a FoSR model.</p></li>
<li><p>Estimate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mover><mi>Ïµ</mi><mo accent="true">Ì‚</mo></mover><mi>N</mi><mo>*</mo></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat{\epsilon}_N^*(s)</annotation></semantics></math>
from
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>g</mi><mn>1</mn></msub><msub><mi>Y</mi><mn>1</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>â€¦</mi><mo>,</mo><msub><mi>g</mi><mi>N</mi></msub><msub><mi>Y</mi><mi>N</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">g_1 Y_1(s), \ldots, g_N Y_N(s)</annotation></semantics></math>.</p></li>
<li><p>Compute
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>T</mi><mo>*</mo></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mfrac><mn>1</mn><msqrt><mi>N</mi></msqrt></mfrac><munderover><mo>âˆ‘</mo><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><msub><mi>g</mi><mi>n</mi></msub><mfrac><mrow><msubsup><mi>R</mi><mi>n</mi><mi>N</mi></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><msubsup><mover><mi>Ïµ</mi><mo accent="true">Ì‚</mo></mover><mi>N</mi><mo>*</mo></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac></mrow><annotation encoding="application/x-tex">
T^*(s) = \frac{1}{\sqrt{N}} \sum_{n=1}^N g_n \frac{R_n^N(s)}{\hat{\epsilon}_N^*(s)}
</annotation></semantics></math></p></li>
<li><p>Repeat steps 1 to 3 many times. Take the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>âˆ’</mo><mi>Î±</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>â‹…</mo><mn>100</mn><mi>%</mi></mrow><annotation encoding="application/x-tex">(1 - \alpha) \cdot 100\%</annotation></semantics></math>
quantile of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>â„’</mi><mo>*</mo></msup><annotation encoding="application/x-tex">\mathcal{L}^*</annotation></semantics></math>
to estimate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>q</mi><mrow><mi>Î±</mi><mo>,</mo><mi>N</mi></mrow></msub><annotation encoding="application/x-tex">q_{\alpha, N}</annotation></semantics></math>.</p></li>
</ol>
<p>At step 2, we allow three choices for the multiplier distribution
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>g</mi><mi>i</mi></msub><annotation encoding="application/x-tex">g_i</annotation></semantics></math>,
each with mean zero and unit variance:</p>
<ol style="list-style-type: decimal">
<li><p><code>rademacher</code>:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>g</mi><mi>i</mi></msub><mo>âˆˆ</mo><mo stretchy="false" form="prefix">{</mo><mi>âˆ’</mi><mn>1</mn><mo>,</mo><mi>+</mi><mn>1</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">g_i \in \{-1,+1\}</annotation></semantics></math>
with equal probability;</p></li>
<li><p><code>gaussian</code>:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>g</mi><mi>i</mi></msub><mo>âˆ¼</mo><mi>ğ’©</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">g_i \sim \mathcal{N}(0,1)</annotation></semantics></math>;</p></li>
<li><p><code>mammen</code>: a twoâ€“point distribution with mean
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math>
and variance
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>
from .</p></li>
</ol>
<p>Unless stated otherwise, we use the <code>rademacher</code>
multipliers.</p>
<p>At step 3, we consider two alternatives for the pointwise standard
errors
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mover><mi>Ïµ</mi><mo accent="true">Ì‚</mo></mover><mi>N</mi><mo>*</mo></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>s</mi><mi>j</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat{\epsilon}_N^*(s_j)</annotation></semantics></math>:</p>
<ol style="list-style-type: decimal">
<li><p><code>regular</code>,
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mover><mi>Ïµ</mi><mo accent="true">Ì‚</mo></mover><mi>N</mi><mo>*</mo></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>s</mi><mi>j</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msqrt><mrow><mfrac><mn>1</mn><mi>n</mi></mfrac><munderover><mo>âˆ‘</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mo minsize="1.2" maxsize="1.2" stretchy="false" form="prefix">(</mo><msub><mi>Y</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>s</mi><mi>j</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>âˆ’</mo><mover><mi>Î²</mi><mo accent="true">Ì‚</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>s</mi><mi>j</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><msup><mo minsize="1.2" maxsize="1.2" stretchy="false" form="postfix">)</mo><mn>2</mn></msup><mi>/</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>âˆ’</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow></msqrt><mspace width="0.167em"></mspace><mo>;</mo></mrow><annotation encoding="application/x-tex">
 \hat{\epsilon}_N^*(s_j)
 = \sqrt{\frac{1}{n}\sum_{i=1}^n\big(Y_i(s_j)-\hat{\beta}(s_j)\big)^2/(n-1)}\,;
  </annotation></semantics></math></p></li>
<li><p><code>t</code>,
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mover><mi>Ïµ</mi><mo accent="true">Ì‚</mo></mover><mi>N</mi><mo>*</mo></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>s</mi><mi>j</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msqrt><mrow><mfrac><mi>N</mi><mrow><mi>N</mi><mo>âˆ’</mo><mn>1</mn></mrow></mfrac><mspace width="0.167em"></mspace><mo minsize="1.8" maxsize="1.8" stretchy="false" form="prefix">|</mo><msub><mi>ğ”¼</mi><mi>b</mi></msub><mspace width="-0.167em"></mspace><mo minsize="1.2" maxsize="1.2" stretchy="false" form="prefix">[</mo><msup><mi>Y</mi><mi>b</mi></msup><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>s</mi><mi>j</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><mo minsize="1.2" maxsize="1.2" stretchy="false" form="postfix">]</mo><mo>âˆ’</mo><mo minsize="1.2" maxsize="1.2" stretchy="false" form="prefix">(</mo><msub><mi>ğ”¼</mi><mi>b</mi></msub><mrow><mo stretchy="true" form="prefix">[</mo><msup><mi>Y</mi><mi>b</mi></msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>s</mi><mi>j</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">]</mo></mrow><msup><mo minsize="1.2" maxsize="1.2" stretchy="false" form="postfix">)</mo><mn>2</mn></msup><mo minsize="1.8" maxsize="1.8" stretchy="false" form="prefix">|</mo></mrow></msqrt><mo>,</mo></mrow><annotation encoding="application/x-tex">
 \hat{\epsilon}_N^*(s_j)
 = \sqrt{\frac{N}{N-1}\,\Big|\mathbb{E}_b\!\big[Y^{b}(s_j)^2\big]
   - \big(\mathbb{E}_b[Y^{b}(s_j)]\big)^2\Big|},
  </annotation></semantics></math> where expectations are taken over
bootstrap replicates and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>Y</mi><mi>b</mi></msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>s</mi><mi>j</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">Y^{b}(s_j)</annotation></semantics></math>
denotes the perturbed sample at iteration
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>.
The absolute value improves numerical stability when subtracting nearly
equal quantities.</p></li>
</ol>
<p>Unless noted otherwise, we report results using the <code>t</code>
estimator.</p>
</div>
</div>
<div class="section level2">
<h2 id="construction-of-simultaneous-confidence-bands-for-linearlogistic-regression-model">Construction of Simultaneous Confidence Bands for Linear/Logistic
Regression Model<a class="anchor" aria-label="anchor" href="#construction-of-simultaneous-confidence-bands-for-linearlogistic-regression-model"></a>
</h2>
<p>We next describe the bootstrap algorithm used to construct
simultaneous confidence intervals (SCIs) for the mean outcome of
regression on a fixed test design matrix. We also use the same
procedures for the construction of SCIs for the regression coefficients.
For details of this algorithm, please refer to .</p>
<p>Suppose we have training data outcome
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>,
design matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>,
and a fixed test design matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>X</mi><mo accent="true">Ìƒ</mo></mover><annotation encoding="application/x-tex">\tilde{X}</annotation></semantics></math>.
Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>Î²</mi><mo>,</mo><mi>X</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f(\beta, X)</annotation></semantics></math>
denote the fitted regression function. The algorithm proceeds as
follows.</p>
<p>First, we estimate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>Î²</mi><mo accent="true">Ì‚</mo></mover><annotation encoding="application/x-tex">\hat{\beta}</annotation></semantics></math>
on the training data
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>y</mi><mo>,</mo><mi>X</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(y, X)</annotation></semantics></math>
using least squares. Then we compute the estimated mean outcome on the
test design matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>E</mi><mo accent="true">Ì‚</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mover><mi>y</mi><mo accent="true">Ìƒ</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow><mo>:=</mo><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mover><mi>Î²</mi><mo accent="true">Ì‚</mo></mover><mo>,</mo><mover><mi>X</mi><mo accent="true">Ìƒ</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat{E}(\tilde{y}) := f(\hat{\beta}, \tilde{X})</annotation></semantics></math>,
together with its standard deviation
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>Ïƒ</mi><mo accent="true">Ì‚</mo></mover><annotation encoding="application/x-tex">\hat{\sigma}</annotation></semantics></math>.</p>
<p>For bootstrap samples
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>â€¦</mi><mo>,</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">b=1,\ldots,L</annotation></semantics></math>,
repeat:</p>
<ol style="list-style-type: decimal">
<li><p>Resample
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>y</mi><mi>b</mi></msub><mo>,</mo><msub><mi>X</mi><mi>b</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(y_b, X_b)</annotation></semantics></math>
with replacement from the training data.</p></li>
<li><p>Fit the model on the resampled data to obtain
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>Î²</mi><mo accent="true">Ì‚</mo></mover><mi>b</mi></msub><annotation encoding="application/x-tex">\hat{\beta}_b</annotation></semantics></math>.</p></li>
<li><p>Compute the estimated mean
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>E</mi><mo accent="true">Ì‚</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><msub><mover><mi>y</mi><mo accent="true">Ìƒ</mo></mover><mi>b</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>:=</mo><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mover><mi>Î²</mi><mo accent="true">Ì‚</mo></mover><mi>b</mi></msub><mo>,</mo><mover><mi>X</mi><mo accent="true">Ìƒ</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat{E}(\tilde{y}_b):=f(\hat{\beta}_b, \tilde{X})</annotation></semantics></math>
and its pointwise standard deviation
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>Ïƒ</mi><mo accent="true">Ì‚</mo></mover><mi>b</mi></msub><annotation encoding="application/x-tex">\hat{\sigma}_b</annotation></semantics></math>.</p></li>
<li><p>Calculate the standardized absolute residuals on the test design
grid,
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>r</mi><mi>b</mi></msub><mo>=</mo><mfrac><mrow><mo minsize="1.2" maxsize="1.2" stretchy="false" form="prefix">|</mo><mover><mi>E</mi><mo accent="true">Ì‚</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><msub><mover><mi>y</mi><mo accent="true">Ìƒ</mo></mover><mi>b</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>âˆ’</mo><mover><mi>E</mi><mo accent="true">Ì‚</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mover><mi>y</mi><mo accent="true">Ìƒ</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow><mo minsize="1.2" maxsize="1.2" stretchy="false" form="prefix">|</mo></mrow><msub><mover><mi>Ïƒ</mi><mo accent="true">Ì‚</mo></mover><mi>b</mi></msub></mfrac><mi>.</mi></mrow><annotation encoding="application/x-tex">
  r_b = \frac{\big| \hat{E}(\tilde{y}_b) - \hat{E}(\tilde{y}) \big|}{\hat{\sigma}_b}.
  </annotation></semantics></math></p></li>
<li><p>Record the maximum value of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>r</mi><mi>b</mi></msub><annotation encoding="application/x-tex">r_b</annotation></semantics></math>
as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>r</mi><mi>b</mi><mo>max</mo></msubsup><annotation encoding="application/x-tex">r^{\max}_b</annotation></semantics></math>.</p></li>
</ol>
<p>After
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>
bootstrap iterations, take the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>âˆ’</mo><mi>Î±</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(1-\alpha)</annotation></semantics></math>
quantile of the empirical distribution of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><msubsup><mi>r</mi><mi>b</mi><mo>max</mo></msubsup><msubsup><mo stretchy="false" form="postfix">}</mo><mrow><mi>b</mi><mo>=</mo><mn>1</mn></mrow><mi>L</mi></msubsup></mrow><annotation encoding="application/x-tex">\{r^{\max}_b\}_{b=1}^L</annotation></semantics></math>
as the threshold
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>.
The SCI on the test design matrix is then given by
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo minsize="1.8" maxsize="1.8" stretchy="false" form="prefix">(</mo><mover><mi>E</mi><mo accent="true">Ì‚</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mover><mi>y</mi><mo accent="true">Ìƒ</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow><mo>âˆ’</mo><mi>a</mi><mo>Ã—</mo><mover><mi>Ïƒ</mi><mo accent="true">Ì‚</mo></mover><mo>,</mo><mspace width="0.278em"></mspace><mspace width="0.278em"></mspace><mover><mi>E</mi><mo accent="true">Ì‚</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mover><mi>y</mi><mo accent="true">Ìƒ</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mi>a</mi><mo>Ã—</mo><mover><mi>Ïƒ</mi><mo accent="true">Ì‚</mo></mover><mo minsize="1.8" maxsize="1.8" stretchy="false" form="postfix">)</mo><mi>.</mi></mrow><annotation encoding="application/x-tex">
\Big( \hat{E}(\tilde{y}) - a \times \hat{\sigma}, \;\; \hat{E}(\tilde{y}) + a \times \hat{\sigma} \Big).
</annotation></semantics></math> For logistic regression, the SCI is
further transformed back to the data scale using the link function.</p>
</div>
<div class="section level2">
<h2 id="construction-of-scb-for-spatial-generalized-least-square-model">Construction of SCB for Spatial Generalized Least Square Model<a class="anchor" aria-label="anchor" href="#construction-of-scb-for-spatial-generalized-least-square-model"></a>
</h2>
<p>We also provide tools in SCoRES for estimating SCB of geographic
data, however, their use is currently limited to the spatial generalized
least squares model.</p>
<p>Let the spatial domain be sampled on spots
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>âˆˆ</mo><mi>ğ’®</mi></mrow><annotation encoding="application/x-tex">s\in\mathcal S</annotation></semantics></math>
with coordinates
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>x</mi><mi>s</mi></msub><mo>,</mo><msub><mi>y</mi><mi>s</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">s=(x_s,y_s)</annotation></semantics></math>.
At each spot
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math>,
we observe
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
outcomes
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ğ³</mi><mi>s</mi></msub><mo>âˆˆ</mo><msup><mi>â„</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\mathbf z_s\in\mathbb R^{n}</annotation></semantics></math>
with design matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ—</mi><mo>âˆˆ</mo><msup><mi>â„</mi><mrow><mi>n</mi><mo>Ã—</mo><mi>p</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\mathbf X\in\mathbb R^{n\times p}</annotation></semantics></math>.
We fit a spot-specific generalized least squares (GLS) model</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ğ³</mi><mi>s</mi></msub><mo>=</mo><mi>ğ—</mi><mi>ğ›ƒ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msub><mi>ğ›†</mi><mi>s</mi></msub><mo>,</mo><mspace width="2.0em"></mspace><msub><mi>ğ›†</mi><mi>s</mi></msub><mo>âˆ¼</mo><mi>ğ’©</mi><mspace width="-0.167em"></mspace><mrow><mo stretchy="true" form="prefix">(</mo><mn>ğŸ</mn><mo>,</mo><mspace width="0.222em"></mspace><msub><mi>ğ•</mi><mi>s</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mrow><annotation encoding="application/x-tex">
\mathbf z_s=\mathbf X\boldsymbol\beta(s)+\boldsymbol\varepsilon_s,\qquad
\boldsymbol\varepsilon_s\sim \mathcal N\!\left(\mathbf 0,\ \mathbf V_s\right),
</annotation></semantics></math></p>
<p>where the variance-covariance matrix within the spot encodes the
prespecified correlation structure
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ğ•</mi><mi>s</mi></msub><annotation encoding="application/x-tex">\mathbf V_s</annotation></semantics></math>.</p>
<p>SCoRES allows users to directly input the matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ğ•</mi><mi>s</mi></msub><annotation encoding="application/x-tex">\mathbf V_s</annotation></semantics></math>
for each spot
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math>,
or specify the correlation structure
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ‘</mi><annotation encoding="application/x-tex">\mathbf R</annotation></semantics></math>.</p>
<p>Assume we are interested in the linear functional
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Î·</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msup><mi>ğ°</mi><mi>âŠ¤</mi></msup><mi>ğ›ƒ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\eta(s)=\mathbf w^\top \boldsymbol\beta(s)</annotation></semantics></math>,
with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ°</mi><annotation encoding="application/x-tex">\mathbf w</annotation></semantics></math>
as a weight vector for the specific linear combination. The pointwise
estimated standard error is</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>Î¶</mi><mo accent="true">Ì‚</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msqrt><mrow><msup><mi>ğ°</mi><mi>âŠ¤</mi></msup><mrow><mi mathvariant="normal">V</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>Î²</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.167em"></mspace><mi>ğ°</mi></mrow></msqrt><mi>.</mi></mrow><annotation encoding="application/x-tex">
\widehat{\zeta}(s)=\sqrt{\mathbf w^\top \mathrm{Var}(\beta(s))\, \mathbf w}.
</annotation></semantics></math></p>
<p>To quantify uncertainty uniformly across spots, we construct a
simultaneous confidence band (SCB) for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Î·</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>â‹…</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\eta(\cdot)</annotation></semantics></math>
on the grid
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ’®</mi><annotation encoding="application/x-tex">\mathcal S</annotation></semantics></math>:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">S</mi><mi mathvariant="normal">C</mi><mi mathvariant="normal">B</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo>;</mo><mspace width="0.167em"></mspace><msub><mi>q</mi><mi>Î±</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mo minsize="1.8" maxsize="1.8" stretchy="false" form="prefix">[</mo><mspace width="0.222em"></mspace><mover><mi>Î·</mi><mo accent="true">Ì‚</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>âˆ’</mo><msub><mi>q</mi><mi>Î±</mi></msub><mspace width="0.167em"></mspace><mover><mi>Î¶</mi><mo accent="true">Ì‚</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mspace width="0.222em"></mspace><mspace width="0.222em"></mspace><mover><mi>Î·</mi><mo accent="true">Ì‚</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msub><mi>q</mi><mi>Î±</mi></msub><mspace width="0.167em"></mspace><mover><mi>Î¶</mi><mo accent="true">Ì‚</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.222em"></mspace><mo minsize="1.8" maxsize="1.8" stretchy="false" form="postfix">]</mo><mo>,</mo><mspace width="2.0em"></mspace><mi>s</mi><mo>âˆˆ</mo><mi>ğ’®</mi><mo>,</mo></mrow><annotation encoding="application/x-tex">
\mathrm{SCB}(s;\,q_\alpha)=\Big[\ \widehat{\eta}(s)-q_\alpha\,\widehat{\zeta}(s),\ \
\widehat{\eta}(s)+q_\alpha\,\widehat{\zeta}(s)\ \Big],\qquad s\in\mathcal S,
</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>q</mi><mi>Î±</mi></msub><annotation encoding="application/x-tex">q_\alpha</annotation></semantics></math>
satisfies</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>â„™</mi><mspace width="-0.167em"></mspace><mrow><mo stretchy="true" form="prefix">(</mo><munder><mo>max</mo><mrow><mi>s</mi><mo>âˆˆ</mo><mi>ğ’®</mi></mrow></munder><mfrac><mrow><mo stretchy="true" form="prefix">|</mo><mover><mi>Î·</mi><mo accent="true">Ì‚</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>âˆ’</mo><mi>Î·</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">|</mo></mrow><mrow><mover><mi>Î¶</mi><mo accent="true">Ì‚</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac><mo>â‰¤</mo><msub><mi>q</mi><mi>Î±</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>1</mn><mo>âˆ’</mo><mi>Î±</mi><mi>.</mi></mrow><annotation encoding="application/x-tex">
\mathbb P\!\left(\max_{s\in\mathcal S}\frac{|\widehat{\eta}(s)-\eta(s)|}{\widehat{\zeta}(s)}
\le q_\alpha\right)= 1-\alpha.
</annotation></semantics></math></p>
<p>We estimate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>q</mi><mi>Î±</mi></msub><annotation encoding="application/x-tex">q_\alpha</annotation></semantics></math>
by
multiplier-<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
bootstrap method introduced before.</p>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0" line-spacing="2">
<div id="ref-crainiceanu2024functional" class="csl-entry">
Crainiceanu, C. M., Goldsmith, J., Leroux, A., &amp; Cui, E. (2024).
<em>Functional data analysis with r</em>. Chapman; Hall/CRC.
</div>
<div id="ref-Ren:2024" class="csl-entry">
Ren, J., Telschow, F. J. E., &amp; Schwartzman, A. (2024). Inverse set
estimation and inversion of simultaneous confidence intervals.
<em>Journal of the Royal Statistical Society Series C: Applied
Statistics</em>, <em>73</em>(4), 1082â€“1109. <a href="https://doi.org/10.1093/jrsssc/qlae027" class="external-link">https://doi.org/10.1093/jrsssc/qlae027</a>
</div>
<div id="ref-Sommerfeld:2018" class="csl-entry">
Sommerfeld, M., Sain, S., &amp; Schwartzman, A. (2018). Confidence
regions for spatial excursion sets from repeated random field
observations, with an application to climate. <em>Journal of the
American Statistical Association</em>, <em>113</em>(523), 1327â€“1340. <a href="https://doi.org/10.1080/01621459.2017.1341838" class="external-link">https://doi.org/10.1080/01621459.2017.1341838</a>
</div>
<div id="ref-Telschow:2022" class="csl-entry">
Telschow, F. J. E., &amp; Schwartzman, A. (2022). Simultaneous
confidence bands for functional data using the gaussian kinematic
formula. <em>Journal of Statistical Planning and Inference</em>,
<em>216</em>, 70â€“94. <a href="https://doi.org/10.1016/j.jspi.2021.05.008" class="external-link">https://doi.org/10.1016/j.jspi.2021.05.008</a>
</div>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Zhuoran Yu, Armin Schwartzman, Junting Ren, Julia Wrobel.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.3.</p>
</div>

    </footer>
</div>





  </body>
</html>
